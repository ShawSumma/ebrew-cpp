
let {Tree, Form, Ident, Number, Text, Parser} = import("./parser.temper");

let Cont = fn(AnyValue): Void;

var hasTodo = false;
var todoArg: AnyValue = 0;
var todoCont: Cont = fn(v: AnyValue): Void {}

let runTodo(): Void {
  while (hasTodo) {
    hasTodo = false;
    todoCont(todoArg);
  }
}

class Err {
  public msg: String;

  constructor(err: String) {
    console.log(err);
    msg = err;
  }
}

class Def {
  public key: String;
  public value: AnyValue;
}

interface Scope {
  public lookup(name: String): AnyValue;
  public toString(): String;
}

class GlobalScope extends Scope {
  public vars: ListBuilder<Def>;

  public lookup(name: String): AnyValue {
    for (var i = vars.length-1; i >= 0; i--) {
      if (vars[i].key == name) {
        return vars[i].value;
      }
    }
    return new Err("undefined: ${name}");
  }

  public add(def: Def): Void {
    vars.add(def);
  }

  public toString(): String {
    return "{...}";
  }
}

class LocalScope extends Scope {
  public next: Scope;
  public keys: List<String>;
  public values: ListBuilder<AnyValue>;

  public lookup(name: String): AnyValue {
    for (var i = 0; i < keys.length; i++) {
      if (keys[i] == name) {
        return values[i];
      }
    }
    return next.lookup(name);
  }

  public toString(): String {
    var my = keys.join(" ", fn(s: String):String{s});
    return "{${my}} ${next.toString()}"
  }
}

interface Runner {
  public run(env: LocalScope, cont: Cont): Void;
}

class ErrRunner extends Runner {}  

class LookupRunner extends Runner {
  public name: String;

  public run(env: LocalScope, cont: Cont): Void {
    todoCont = cont;
    todoArg = env.lookup(name);
    hasTodo = true;
  }
}

let Define = fn(List<AnyValue>, Cont): Void;

class DefineRunner extends Runner {
  public callback: Define;

  public run(env: LocalScope, cont: Cont): Void {
    callback(env.values.toList(), cont);
  }
}

class Lambda {
  public lambdaScope: LocalScope;
  public argNames: List<String>;
  public bodyRunner: Runner;
}

class LambdaRunner extends Runner {
  public argNames: List<String>;
  public bodyRunner: Runner;
  
  public run(env: LocalScope, cont: Cont): Void {
    todoCont = cont;
    todoArg = new Lambda(env, argNames, bodyRunner);
    hasTodo = true;
  }
}

class CallRunner extends Runner {
  public funcName: String;
  public args: List<Runner>;

  public run(env: LocalScope, cont: Cont): Void {
    let {lambdaScope, argNames, bodyRunner} = env.lookup(funcName).as<Lambda>();
    var scopeArgs = new ListBuilder<AnyValue>();
    if (argNames.length == 0) {
      bodyRunner.run(new LocalScope(lambdaScope, argNames, scopeArgs), cont);
    } else {
      let self = this;

      let more(v: AnyValue): Void {
        scopeArgs.add(v);
        if (scopeArgs.length == self.args.length) {
          bodyRunner.run(new LocalScope(lambdaScope, argNames, scopeArgs), cont);
        } else {
          self.args[scopeArgs.length].run(env, more);
        }
      }

      self.args[0].run(env, more);
    }
  }
}

class ValueRunner extends Runner {
  public value: AnyValue;

  public run(env: LocalScope, cont: Cont): Void {
    todoCont = cont;
    todoArg = value;
    hasTodo = true;
  }
}

let stringList(id: String): AnyValue {
  var ret: AnyValue = 0;
  var parts = id.split("");
  for (var i = parts.length - 1; i >= 0; i--) {
    var t: List<AnyValue> = [parts[i].codePoints.read(), ret];
    ret = t;
  }
  return ret;
}

export class Env {
  public env: GlobalScope;
  public parser: Parser;
  var putCharBuf: ListBuilder<Int>;

  public constructor() {
    env = new GlobalScope(new ListBuilder<Def>());
    parser = new Parser("");
    putCharBuf = new ListBuilder<Int>();
  }
 
  public source(code: String): Void {
    parser.setState(code);
    var prog = parser.readDefs();
    compProgram(prog);
  }

  public call(name: String, args: List<AnyValue>): AnyValue {
    var realArgs = args.map(fn(v: AnyValue): AnyValue {
      match (v) {
        is String -> return stringList(v.as<String>());
        else -> return v;
      }
    });
    var func = env.lookup(name).as<Lambda>();
    var res: AnyValue = 0;
    var cont = fn(v: AnyValue): Void {
      res = v;
    };
    var localEnv = new LocalScope(func.lambdaScope, func.argNames, realArgs.toListBuilder());
    func.bodyRunner.run(localEnv, cont);
    runTodo();
    return res;
  }


  public compErr(): Runner {
    return new ErrRunner();
  }

  public compLambda(form: Form): Runner {
    var argNames = form.args[0].as<Form>().args.map(fn(s: Tree): String {
      return s.as<Ident>().repr;
    });
    var bodyRunner = compTree(form.args[1]);
    return new LambdaRunner(argNames, bodyRunner);
  }

  public compCall(form: Form): Runner {
    var funcName = form.args[0].as<Ident>().repr;
    var self = this;
    var args = form.args.slice(1, form.args.length).map(fn(t: Tree): Runner {self.compTree(t)});
    return new CallRunner(funcName, args);
  }

  public compForm(form: Form): Runner {
    match (form.form) {
      "call" -> compCall(form);
      "lambda" -> compLambda(form);
      else -> compErr();
    }
  }

  public compTree(tree: Tree): Runner {
    match (tree) {
      is Form -> compForm(tree.as<Form>());
      is Ident -> new LookupRunner(tree.as<Ident>().repr);
      is Number -> new ValueRunner(tree.as<Number>().repr);
      is Text -> new ValueRunner(stringList(tree.as<Text>().repr));
      else -> compErr();
    }
  }

  public flush(): Void {
    let {fromAsciiCode} = import("./ascii.temper");
    console.log(putCharBuf.join("", fromAsciiCode));
    putCharBuf = new ListBuilder<Int>();
  }

  public putchar(c: Int): Void {
    putCharBuf.add(c);
  }

  public compExternName(name: String): Define {
    var self = this;
    match (name) {
      "equal" -> fn(args: List<AnyValue>, k: Cont): Void {
        if (args[0].as<Int>() == args[1].as<Int>()) {
          k(1);
        } else {
          k(0);
        }
      };
      "above" -> fn(args: List<AnyValue>, k: Cont): Void {
        if (args[1].as<Int>() < args[0].as<Int>()) {
          k(1);
        } else {
          k(0);
        }
      };
      "pair" -> fn(args: List<AnyValue>, k: Cont): Void {
        k([args[0], args[1]]);
      };
      "first" ->  fn(args: List<AnyValue>, k: Cont): Void {
        k(args[0].as<List<AnyValue>>()[0]);
      };
      "second" ->  fn(args: List<AnyValue>, k: Cont): Void {
        k(args[0].as<List<AnyValue>>()[1]);
      };
      "add" ->  fn(args: List<AnyValue>, k: Cont): Void {
        k(args[1].as<Int>() + args[0].as<Int>());
      };
      "sub" ->  fn(args: List<AnyValue>, k: Cont): Void {
        k(args[1].as<Int>() - args[0].as<Int>());
      };
      "mul" ->  fn(args: List<AnyValue>, k: Cont): Void {
        k(args[1].as<Int>() * args[0].as<Int>());
      };
      "div" ->  fn(args: List<AnyValue>, k: Cont): Void {
        k(args[1].as<Int>() / args[0].as<Int>());
      };
      "mod" ->  fn(args: List<AnyValue>, k: Cont): Void {
        k(args[1].as<Int>() % args[0].as<Int>());
      };
      "putchar" -> fn(args: List<AnyValue>, k: Cont): Void {
        var c = args[0].as<Int>();
        if (c == 10) {
          self.flush();
        } else {
          self.putchar(c);
        }
        k(0);
      };
      "if" ->  fn(args: List<AnyValue>, k: Cont): Void {
        var func = match (args[0]) {
          0 -> args[2].as<Lambda>();
          else -> args[1].as<Lambda>();
        };
        func.bodyRunner.run(func.lambdaScope, k);
      };
      else -> fn(args: List<AnyValue>, k: Cont): Void {
        k(new Err("no such import: (${name} ...) ?"));
      };
    }
  }

  public compExtern(form: Form): Void {
    var name = form.args[0].as<Form>().args[0].as<Ident>().repr;
    var argNames = form.args[1].as<Form>().args.map(fn(x: Tree): String {
      return x.as<Form>().args[0].as<Ident>().repr;
    });
    var localEnv = new LocalScope(env, [], new ListBuilder<AnyValue>());
    var lambda = new Lambda(localEnv, argNames, new DefineRunner(compExternName(name)));
    env.add(new Def(name, lambda));
  }

  public compFunc(form: Form): Void {
    var name = form.args[0].as<Form>().args[0].as<Ident>().repr;
    var argNames = form.args[1].as<Form>().args.map(fn(x: Tree): String {
      return x.as<Form>().args[0].as<Ident>().repr;
    });
    var bodyRunner = compTree(form.args[2]);
    var localEnv = new LocalScope(env, [], new ListBuilder<AnyValue>());
    var lambda = new Lambda(localEnv, argNames, bodyRunner);
    env.add(new Def(name, lambda));
  }

  public compTopForm(form: Form): Void {
    match (form.form) {
      "extern" -> compExtern(form);
      "func" -> compFunc(form);
      else -> compErr();
    }
  }

  public compProgram(tree: Tree): Void {
    var form = tree.as<Form>();
    for (var i = 0; i < form.args.length; i++) {
      compTopForm(form.args[i].as<Form>());
    }
  }
}