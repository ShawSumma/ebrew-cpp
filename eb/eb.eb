
# builtin #

(if c (t) (f)) ?

(pair a b) ?
(first p) ?
(second p) ?

(putchar char) ?

(equal y x) ?
(above y x) ?

(add y x) ?
(sub y x) ?
(mul y x) ?
(div y x) ?
(mod y x) ?

# common #

(or x (y))
if x x y

(and x (y))
if x y 0

(not x)
if x 0 1

(do x y)
y

# variables #

(let [val] val (in val))
in val

# looping #

(for [name] list (in name))
and list
do  in first list
    for name second list in name


(fold [last name] start list (in last name))
if  list
    in  fold last name start second list in last name
        first list
    start

(map [name] list (in name))
and list
pair in first list
     map name second list in name

(contains list (check el))
and list
    or  check first list
        contains second list check el

(length list)
and list
    add 1 length second list

# io #

(put-line)
putchar 10

(put-str s)
for k s putchar k

(put-digit n)
putchar add '0 mod 10 n

(put-num-nonzero n)
and above n 0
do  put-num-nonzero div 10 n
    put-digit n

(put-num n)
if  n
    put-num-nonzero n
    put-digit 0

(put-list-sep-from n tree (sep) (then el))
and tree
do  and n sep
do  then first tree
    put-list-sep-from
        add 1 n
        second tree
        sep
        then el

(put-list-sep tree (sep) (then el))
put-list-sep-from 0 tree sep then el

# lists #

(reverse-from list res)
if  list
    reverse-from second list pair first list res
    res

(reverse list)
reverse-from list 0

(concat x y)
if  x
    pair first x concat second x y
    y

# strings #

(str-eq x y)
if  x
    if  y
        and equal  first  x first  y
            str-eq second x second y
        0
    if  y
        0
        1

(num-to-str-nonzero n)
and above n 0
concat
    num-to-str-nonzero div 10 n
    pair add '0 mod 10 n 0

(num-to-str n)
if  n
    num-to-str-nonzero n
    "0"

(rstr-to-num x)
and x
    add mul 10 rstr-to-num second x
        sub '0 first x

(str-to-num x)
rstr-to-num reverse x

# error library #

(error-from-str msg) pair 0 msg
(error-from-both n1 n2) pair 1 pair n1 n2
(error-from-wanted exp) pair 2 exp
(error-from-got rec) pair 3 rec
(error-from-position pos error) pair 4 pair pos error
(error-from-char chr) pair 5 chr

(error-is-str error) equal 0 first error
(error-is-both error) equal 1 first error
(error-is-wanted error) equal 2 first error
(error-is-got error) equal 3 first error
(error-is-position error) equal 4 first error
(error-is-char error) equal 5 first error

(put-error-body error)
if  error-is-char error
    if  equal 10 second error
        put-str "newline"
    if  equal 32 second error
        put-str "space"
    if  equal 39 second error
        put-str "signle quote"
        do  putchar 39
        do  putchar second error
            putchar 39
if  error-is-str error
    put-str second error
if  error-is-both error
    do  put-error-body first second error
    do  put-str " "
        put-error-body second second error
if  error-is-wanted error
    do  put-str "(Wanted: "
    do  put-error-body second error
        put-str ")"
if  error-is-got error
    do  put-str "(Got: "
    do  put-error-body second error
        put-str ")"
if  error-is-position error
    let pos first second error
    do  put-str "At Line "
    do  put-num first pos
    do  put-str ", Col "
    do  put-num second pos
    do  put-str ": "
        put-error-body second second error
    0

(put-error error)
do  put-error-body error
    put-line
# parser library #

(state-has-data str)
second str

(state-data str)
first second str

(state-pos str)
first str

(state-line str)
first state-pos str

(state-col str)
second state-pos str

(str-to-state str)
pair pair 1 1 str

(state-skip str)
let data second str
let chr state-data str
let col state-col str
let line state-line str
    pair
        if  equal chr 10
            pair add 1 line 1
            pair line       add 1 col
        second data

(strip-comment str)
if  not state-has-data str
    str
let chr state-data str
if  equal '# chr
    state-skip str
    strip-comment state-skip str

(strip str)
if  not state-has-data str
    str
let chr state-data str
if  equal '# chr
    strip strip-comment state-skip str
if  or  equal '   chr
        equal 10  chr
    strip state-skip str
    str

(parse-any str (then value str) (error info))
if  state-has-data str
    then state-data str state-skip str
    error error-from-position state-pos str error-from-got error-from-str "end of file"

(parse-if str (func test) (then value str) (error info))
parse-any str
    if  func value
        then value str
        error error-from-position state-pos str error-from-wanted error-from-str "match unknown criterion"
    error info

(parse-value str value (then value str) (error info))
parse-if str equal value test
    then value str
    error error-from-position state-pos str
        error-from-both
            error-from-wanted error-from-char value
            error-from-got
                if  state-has-data str
                    error-from-char state-data str
                    error-from-str "end of file"

(parse-and str (parse1 str (then value str) (error info)) (parse2 str (then value str) (error info)) (then value str) (error info))
parse1 str
    let v1 value
    parse2 str
        let v2 value
        then pair v1 v2 str
        error info
    error info

(parse-zero-or-more str (parse1 str (then value str) (error info)) (then value str) (error info))
parse-and str
    parse1 str
        then value str
        error info
    parse-zero-or-more str
        parse1 str
            then value str
            error info
        then value str
        error info
    then value str
    then 0 str

(parse-one-or-more str (parse1 str (then value str) (error info)) (then value str) (error info))
parse-and str
    parse1 str
        then value str
        error info
    parse-zero-or-more str
        parse1 str
            then value str
            error info
        then value str
        error info
    then value str
    error info

# bindings #

(binding-of-value)   0
(binding-of-lambda)  1
(binding-of-generic) 2

(binding-value value)       pair binding-of-value  value
(binding-lambda value args generics) pair binding-of-lambda pair value pair args generics
(binding-generic value)     pair binding-of-generic  value

(binding-is-value binding)   equal binding-of-value   first binding
(binding-is-lambda binding)  equal binding-of-lambda  first binding
(binding-is-generic binding) equal binding-of-generic first binding

(get-binding-value binding)
if  binding-is-value binding
    second binding
if  binding-is-generic binding
    second binding
    get-binding-value first second binding

(get-binding-args binding)     first  second second binding
(get-binding-generics binding) second second second binding

(name-table-append table binding) pair binding table
(name-table-lookup table name)
and table
if  str-eq name get-binding-value first table
    first table
    name-table-lookup second table name

(binding-table) pair 0 0

(binding-table-append-generic tab binding)
pair first tab
     name-table-append second tab binding
(binding-table-append tab binding)
pair name-table-append first tab binding
     second tab

(binding-table-lookup-generic tab binding)
name-table-lookup second tab binding

(binding-table-lookup tab binding)
or  name-table-lookup first tab binding
    binding-value binding
# ast #

(ast-of-name)     0
(ast-of-call)     1
(ast-of-function) 2
(ast-of-number)   3
(ast-of-extern)   4
(ast-of-lambda)   5
(ast-of-str)      6

(ast-name name)          pair ast-of-name     name
(ast-call args)          pair ast-of-call     args
(ast-function args then) pair ast-of-function pair args then
(ast-number num)         pair ast-of-number   num
(ast-extern args)        pair ast-of-extern   args
(ast-lambda args then)   pair ast-of-lambda   pair args then
(ast-str str)            pair ast-of-str      str

(ast-is-name tree)     equal ast-of-name     first tree
(ast-is-call tree)     equal ast-of-call     first tree
(ast-is-function tree) equal ast-of-function first tree
(ast-is-number tree)   equal ast-of-number   first tree
(ast-is-extern tree)   equal ast-of-extern   first tree
(ast-is-lambda tree)   equal ast-of-lambda   first tree
(ast-is-str tree)      equal ast-of-str      first tree

(binding-to-ast bind)
if  binding-is-value bind
    ast-name get-binding-value bind
if  binding-is-lambda bind
    ast-call pair
        ast-name get-binding-value bind
        map tree get-binding-args bind
            # binding-to-ast tree #
            ast-name get-binding-value tree
if  binding-is-generic bind
    ast-name get-binding-value bind
    ast-str "???"

# ebrew parser #

(within-range test low high)
and not above test high not above low test

(is-word-char-init test)
or  within-range test 'a 'z
or  within-range test 'A 'Z
or  equal test '-
    equal test '_

(is-digit test)
within-range test '0 '9

(is-word-char test)
or  is-word-char-init test
    is-digit test

(parse-word str (then value str) (error info))
parse-and str
    parse-if strip str is-word-char-init test
        then value str
        error error-from-position state-pos str "expected a start of word character"
    parse-zero-or-more str
        parse-if str is-word-char test
            then value str
            error error-from-position state-pos str "expected word character"
        then value str
        error info
    then value str
    error info

(parse-square str (then value str) (error info))
parse-value strip str '[
    parse-zero-or-more str
        parse-word str
            then value str
            error info
        let ret value
        parse-value strip str ']
            then ret str
            error info
        error info
    then 0 str

(parse-args-from str names (then value str) (error info))
parse-value strip str '(
    parse-word str
        let func value
        parse-square str
            let generics
                fold generics arg
                     0        value
                    pair binding-generic arg generics
            let names
                fold names name
                     names value
                    pair name names
            parse-zero-or-more str
                parse-args-from str names
                    then value str
                    error info
                let args value
                parse-value strip str ')
                    then
                        binding-lambda binding-value func args generics
                        str
                    error info
                error info
            error info
        error info
    parse-word str
        if  contains names str-eq el value
            then binding-generic value str
            then binding-value value str
        error info

(parse-args str (then value str) (error info))
parse-args-from str 0
    then value str
    error info

(parse-generic-args str tab generics (then str tab) (error info))
if  generics
    parse-args str
        let tab binding-table-append-generic tab binding-lambda first generics pair value 0 0
        parse-generic-args str tab second generics
            then str tab
            error info
        error info
    then str tab

(parse-expr-match str tab value (parse-call str tab bindings (parse-expr str tab (then value str tab) (error info)) (then value str tab) (error info)) (parse-expr str tab (then value str tab) (error info)) (then value str tab) (error info))
let binding binding-table-lookup tab value
if  not binding
    error error-from-position state-pos str "unknown name"
if  binding-is-generic binding
    then ast-name value str tab
if  binding-is-value binding
    then ast-name value str tab
if  binding-is-lambda binding
    let v1 value
    parse-generic-args str tab get-binding-generics binding
        parse-call str tab get-binding-args binding
            parse-expr str tab then value str tab error info
            then ast-call pair ast-name v1 value str tab
            error info
        error info
    error error-from-position state-pos str "binding can not be understood"

(parse-call str tab bindings (parse-expr str tab (then value str tab) (error info)) (then value str tab) (error info))
if  bindings
    let binding first bindings
    if  binding-is-generic binding
        let generic-binding-all binding-table-lookup-generic tab get-binding-value binding
        if  generic-binding-all
            let generic-value first get-binding-args generic-binding-all
            let tab binding-table-append tab generic-value
            parse-call str tab pair generic-value second bindings
                parse-expr str tab then value str tab error info
                then value str tab
                error info
            parse-expr str tab
                let v1 value
                parse-call str tab second bindings
                    parse-expr str tab then value str tab error info
                    then pair v1 value str tab
                    error info
                error info
    if  binding-is-value binding
        parse-expr str tab
            let v1 value
            parse-call str tab second bindings
                parse-expr str tab then value str tab error info
                then pair v1 value str tab
                error info
            error info
    if  binding-is-lambda binding
        let tab
            fold tab-with-arg lambda-arg
                 tab          get-binding-args binding
                binding-table-append tab-with-arg lambda-arg
        parse-expr str tab
            let v1  ast-lambda
                    map arg get-binding-args binding
                        ast-name if binding-is-generic arg
                            let gen binding-table-lookup-generic tab get-binding-value arg
                                get-binding-value first get-binding-args gen
                            get-binding-value arg
                    value
            parse-call str tab second bindings
                parse-expr str tab then value str tab error info
                then pair v1 value str tab
                error info
            error info
        error error-from-position state-pos str "binding could not be understood"
    then 0 str tab

(parse-str-expr str (then value str) (error info))
parse-value str '"
    parse-zero-or-more str
        parse-if str not equal '" test
            then value str
            error info
        let ret ast-str value
        parse-value str '"
            then ret str
            error info
        error info
    parse-value str ''
        parse-any str
            then ast-number value str
            error info
        error info

(parse-expr str tab (then0 value str tab) (error info))
let str strip str
let tab-init tab
parse-one-or-more str
    parse-if str is-digit test
        then value str
        error info
    then0 ast-number str-to-num value str tab
    parse-word str
        parse-expr-match str tab value
            parse-call str tab bindings parse-expr str tab then value str tab error info then value str tab error info
            parse-expr str tab then value str tab error info
            then0 value str tab-init
            error info
        parse-str-expr str
            then0 value str tab-init
            error info

(parse-toplevel-single str tab (then value str tab) (error info))
parse-args str
    let func-bind value
    if  binding-is-lambda func-bind
        let func-ast binding-to-ast func-bind
        let tab-with-func binding-table-append tab func-bind
        parse-value strip str '?
            then ast-extern func-ast str tab-with-func
            let tab-with-args
                fold tab-with-arg  func-arg
                     tab-with-func get-binding-args func-bind
                    binding-table-append tab-with-arg func-arg
            parse-expr str tab-with-args
                then ast-function func-ast value str tab-with-func
                error info
        error error-from-position state-pos str "expected toplevel function, not scalar"
    error info

(parse-toplevel str tab (then values str tab) (error info))
if  not state-has-data strip str
    then 0 str tab
    parse-toplevel-single str tab
        parse-toplevel str tab
            then pair value values str tab
            error info
        error info


(defs-append defs name value)
pair pair name value defs

(defs-lookup defs name)
and defs
if  str-eq name first first defs
    second first defs
    defs-lookup second defs name

(ir-form-type-error) 0
(ir-form-type-let) 1
(ir-form-type-block) 2
(ir-form-type-call) 3
(ir-form-type-function) 4
(ir-form-type-params) 5
(ir-form-type-let-closure) 6
(ir-form-type-extern) 7
(ir-form-type-return) 8
(ir-form-type-closure-get) 9
(ir-form-type-let-string) 10
(ir-form-type-let-closure-global) 11

(ir-form-type-to-str type)
if equal type ir-form-type-error "error"
if equal type ir-form-type-let "let"
if equal type ir-form-type-block "block"
if equal type ir-form-type-call "call"
if equal type ir-form-type-function "function"
if equal type ir-form-type-params "params"
if equal type ir-form-type-let-closure "let-closure"
if equal type ir-form-type-extern "extern"
if equal type ir-form-type-return "return"
if equal type ir-form-type-closure-get "closure-get"
if equal type ir-form-type-let-string "let-string"
if equal type ir-form-type-let-closure-global "let-closure-global"
    "unknown"

(ir-of-form type args) pair 0 pair type args
(ir-is-form ir) equal 0 first ir
(ir-form-type ir) first second ir
(ir-form-args ir) second second ir

(ir-of-ident ident) pair 1 ident
(ir-is-ident ir) equal 1 first ir
(ir-ident-text ir) second ir

(ir-of-number number) pair 2 number
(ir-is-number ir) equal 2 first ir
(ir-number-value ir) second ir

(ir-of-string string) pair 3 string
(ir-is-string ir) equal 3 first ir
(ir-string-value ir) second ir

(ir-of-form-block args)
ir-of-form ir-form-type-block
    fold e el
        0 args
        concat
            if  and ir-is-form el equal ir-form-type-block ir-form-type el
                ir-form-args el
                pair el 0
            e

(ir-print-spaces n)
and n
do  putchar 32
    ir-print-spaces sub 1 n

(ir-print-depth ir n)
if  ir-is-form ir
    let type ir-form-type-to-str ir-form-type ir
    let args ir-form-args ir
    do  put-str "("
    do  put-str type
    do  for arg args
        let n add 2 n
        do  put-line
        do  ir-print-spaces n
            ir-print-depth arg n
    do  put-str ")"
        0
if  ir-is-ident ir
    put-str ir-ident-text ir
if  ir-is-number ir
    put-num ir-number-value ir
if  ir-is-string ir
    do  putchar '"
    do  put-str ir-string-value ir
        putchar '"
put-str "<unk>"

(ir-print ir)
ir-print-depth ir 0

(compile-ir-pre tree (get-path) defs (compile-ir tree (get-path) defs))
if  ast-is-call tree
    reverse second fold state el
            pair 0 0 reverse second second tree
        let n first state
        pair add 1 n
            concat
                let path
                    concat get-path
                    concat "_"
                        num-to-str n
                reverse compile-ir-pre
                    el
                    path
                    defs
                    compile-ir tree get-path defs
                second state
if  ast-is-lambda tree
    let path concat get-path "_lam"
    let defs second
        fold duo      def
            pair 0 0  defs
            pair add 1 first duo
                 defs-append second duo first def pair 1 first duo
    let defs second
        fold duo         arg
             pair 0 defs first second tree
            pair add 1 first duo
                 defs-append second duo second arg pair 0 second arg
    concat
        compile-ir-pre
            second second tree
            path
            defs
            compile-ir tree get-path defs
        pair
            ir-of-form ir-form-type-function
                pair ir-of-ident path
                pair ir-of-form ir-form-type-params
                    pair ir-of-ident "closure"
                    map arg first second tree
                        ir-of-ident second arg
                pair ir-of-form-block
                    pair compile-ir second second tree path defs
                    pair ir-of-form ir-form-type-return
                        pair ir-of-ident path
                            0
                        0
                    0
            0
    0

(compile-ir tree (get-path) defs)
if  ast-is-name tree
    let found defs-lookup defs second tree
    ir-of-form ir-form-type-let
        pair ir-of-ident get-path
        pair if and found equal 1 first found
            ir-of-form ir-form-type-closure-get
                pair ir-of-ident "closure"
                pair ir-of-number add 1 second found
                    0
            ir-of-ident second tree
            0
if  ast-is-call tree
    ir-of-form-block
        let lambda-path concat get-path "_clo"
        let func-path concat get-path "_fun"
        let found defs-lookup defs second first second tree
        let func-pair
            #if and found equal 1 first found#
            pair ir-of-form ir-form-type-closure-get
                    pair ir-of-ident lambda-path
                    pair ir-of-number 0
                        0
                ir-of-ident lambda-path
        pair compile-ir first second tree lambda-path defs
        pair ir-of-form ir-form-type-let
            pair ir-of-ident func-path
            pair first func-pair
                0
        pair ir-of-form-block
            reverse second fold state el
                        pair 0 0 reverse second second tree
                    let n first state
                    let path
                        concat get-path
                        concat "_"
                            num-to-str n
                    let arg compile-ir el path defs
                    pair add 1 n pair arg second state
        pair ir-of-form ir-form-type-let
            pair ir-of-ident get-path
            pair ir-of-form ir-form-type-call
                pair ir-of-ident func-path
                reverse pair second func-pair
                    reverse second fold state el
                        pair 0 0 second second tree
                        let n first state
                        pair add 1 n
                        pair ir-of-ident
                                concat get-path
                                concat "_"
                                    num-to-str n
                            second state
                0
            0
if  ast-is-function tree
    let path concat
        second first second first second tree
        "_ret"
    let defs
        fold xdefs arg
             0     second second first second tree
            defs-append xdefs second arg pair 0 second arg
    let pre
        compile-ir-pre
            second second tree
            path
            defs
            compile-ir tree get-path defs
    let base ir-of-form ir-form-type-function
        pair ir-of-ident path
        pair ir-of-form ir-form-type-params
            pair ir-of-ident "closure"
            map arg second second first second tree
                ir-of-ident second arg
        pair ir-of-form-block
            pair compile-ir second second tree path defs
            pair ir-of-form ir-form-type-return
                pair ir-of-ident path
                    0
                0
            0
        pair
            ir-of-form ir-form-type-let-closure
                pair ir-of-ident second first second first second tree
                pair ir-of-ident path
                    0
            concat
                pre
                pair base 0
if  ast-is-number tree
    ir-of-form ir-form-type-let
        pair ir-of-ident get-path
        pair ir-of-number second tree
            0
if  ast-is-extern tree
    pair ir-of-form ir-form-type-extern
        pair ir-of-ident second first second second tree
        pair ir-of-form ir-form-type-params
            map arg second second second tree
                ir-of-ident second arg
            0
        0
if  ast-is-lambda tree
    let defs-init defs
    let path concat get-path "_lam"
    let defs second
        fold duo      def
            pair 0 0  defs
            pair add 1 first duo
                 defs-append second duo first def pair 1 first duo
    let defs second
        fold duo         arg
             pair 0 defs first second tree
            pair add 1 first duo
                 defs-append second duo second arg pair 0 second arg
    ir-of-form ir-form-type-let-closure
        pair ir-of-ident get-path
        pair ir-of-ident path
            map def reverse defs-init
                let found second def
                if equal 1 first found
                    ir-of-form ir-form-type-closure-get
                        pair ir-of-ident "closure"
                        pair ir-of-number add 1 second found
                            0
                    ir-of-ident second found
if  ast-is-str tree
    ir-of-form ir-form-type-let-string
        pair ir-of-ident get-path
        pair ir-of-string second tree
            0
ir-of-ident "<TODO: else>"

(for-ir [name] str (in name))
parse-toplevel str-to-state str binding-table
    for node values
        for el compile-ir node 0 0
            in el
    put-error info

(endline)
pair 10 0

(put-ir-c ir)
if  ir-is-form ir
    let type ir-form-type ir
    let args ir-form-args ir
    if  equal type ir-form-type-let
        do  put-str "  size_t "
        do  put-ir-c first args
        do  put-str " = (size_t) ("
        do  put-ir-c first second args
        do  put-str ");"
        do  put-line
            0
    if  equal type ir-form-type-block
        do  put-str "{"
        do  put-line
        do  put-str "  EB_DEBUG();"
        do  put-line
        do  for arg args
            put-ir-c arg
        do  put-str "}"
        do  put-line
            0
    if  equal type ir-form-type-call
        do  put-str "((size_t (*)("
        do  fold n arg
                 0 second args
                do  and n put-str ", "
                do  put-str "size_t"
                    add 1 n
        do  put-str "))"
        do  put-ir-c first args
        do  put-str ")("
        do  fold n arg
                 0 second args
                do  and n put-str ", "
                do  put-str "(size_t) ("
                do  put-ir-c arg
                do  put-str ")"
                    add 1 n
        do  put-str ")"
            0
    if  equal type ir-form-type-function
        do  put-str "size_t "
        do  put-ir-c first args
        do  put-ir-c first second args
        do  put-ir-c first second second args
            endline
    if  equal type ir-form-type-params
        do  put-str "("
        do  fold n arg
                 0 reverse args
                do  and n put-str ", "
                do  put-str "size_t "
                do  put-ir-c arg
                    add 1 n
        do  put-str ")"
            0
    if  equal type ir-form-type-let-closure-global
        do  put-str "size_t "
        do  put-ir-c first args
        do  put-str "[] = {"
        do  put-line
        do  for arg second args
                do  put-str "  (size_t) ("
                do  put-ir-c arg
                do  put-str "),"
                do  put-line
                    0
        do  put-str "};"
        do  put-line
            0
    if  equal type ir-form-type-let-closure
        do  put-str "  size_t "
        do  put-ir-c first args
        do  put-str "[] = {"
        do  put-line
        do  for arg second args
                do  put-str "    (size_t) ("
                do  put-ir-c arg
                do  put-str "),"
                do  put-line
                    0
        do  put-str "  };"
        do  put-line
            0
    if  equal type ir-form-type-extern
        0
    if  equal type ir-form-type-return
        do  put-str "  return "
        do  put-ir-c first args
        do  put-str ";"
        do  put-line
            0
    if  equal type ir-form-type-closure-get
        do  put-str "((size_t *)"
        do  put-ir-c first args
        do  put-str ")["
        do  put-ir-c first second args
        do  put-str "]"
            0
    if  equal type ir-form-type-let-string
        do  put-str "  static size_t "
        do  put-ir-c first args
        do  put-str " = 0;"
        do  put-line
        do  put-str "  ebz_stol(&"
        do  put-ir-c first args
        do  put-str ", "
        do  put-ir-c first second args
        do  put-str ");"
        do  put-line
            0
        0
if  ir-is-ident ir
    do  put-str "eb_"
    for c ir-ident-text ir
        if  equal c '-
            put-str "_DASH_"
            putchar c
if  ir-is-number ir
    put-num ir-number-value ir
if  ir-is-string ir
    do  put-str pair '" 0
    do  put-str ir-string-value ir
    do  put-str pair '" 0
        0
    0

(put-ir-c-decl ir)
if  and ir-is-form ir
    equal ir-form-type ir ir-form-type-function
    let args ir-form-args ir
    do  put-str "size_t "
    do  put-ir-c first args
    do  put-ir-c first second args
    do  put-str ";"
    do  put-line
        0
    0

(main-lang lang str)
if  str-eq lang "ir"
    for-ir ir str
        do  put-line
        do  ir-print ir
            put-line
if  str-eq lang "c"
    parse-toplevel str-to-state str binding-table
        do  put-str "#include <ebrew.h>"
        do  put-line
        for node values
            let ir compile-ir node 0 0
            do  put-ir-c-decl first reverse ir
            for el ir
                put-ir-c el
        put-error info
do  put-str "unknown target: "
do  put-str lang
    put-line

(read-file name) ?

(comp-final file lang)
main-lang lang read-file file

(comp args file lang)
if  and args str-eq "--target" first args
    comp second second args file first second args
    comp-final first args lang

(main args)
comp args 0 "c"
