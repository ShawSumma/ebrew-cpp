
let {Tree, Form, Ident, Number, Text, Parser} = import("./parser.temper");

class Def {
  public key: String;
  public value: AnyValue;
}

let ExternFunc = fn(List<AnyValue>): AnyValue;

class Extern {
  public callback: ExternFunc;

  public invoke(args: List<AnyValue>): AnyValue {
    return callback(args);
  }
}

export let isBad(v: AnyValue): Boolean {
  match (v) {
    is Err -> return true;
    else -> return false;
  }
}

class Err {
  public msg: String;
}

interface Scope {
  public lookup(name: String): AnyValue;
  public toString(): String;
}

class GlobalScope extends Scope {
  public vars: ListBuilder<Def>;

  public lookup(name: String): AnyValue {
    for (var i = vars.length-1; i >= 0; i--) {
      if (vars[i].key == name) {
        return vars[i].value;
      }
    }
    return new Err("undefined: ${name}");
  }

  public add(def: Def): Void {
    vars.add(def);
  }

  public toString(): String {
    return "{...}";
  }
}

class LocalScope extends Scope {
  public next: Scope;
  public vars: List<Def>;

  public lookup(name: String): AnyValue {
    for (var i = 0; i < vars.length; i++) {
      if (vars[i].key == name) {
        return vars[i].value;
      }
    }
    return next.lookup(name);
  }

  public toString(): String {
    var my = vars.join(" ", fn(d: Def): String { d.key });
    return "{${my}} ${next.toString()}"
  }
}

export class Env {
  public globals: GlobalScope;
  public defs: Scope;
  public parser: Parser;

  public constructor() {
    globals = new GlobalScope(new ListBuilder<Def>());
    defs = globals;
    parser = new Parser("");
  }

  public setDefs(scope: Scope): Void {
    defs = scope;
  }

  public define(name: String, value: fn(List<AnyValue>): AnyValue): Void {
    globals.add(new Def(name, new Extern(value)));
  }

  public source(code: String): Void {
    parser.setState(code);
    runTree(parser.readDefs());
  }

  public call(name: String, args: List<AnyValue>): AnyValue {
    return callTree(getEnv(name), args);
  }

  public runProgram(form: Form): AnyValue {
    var ret: AnyValue = 0;
    for (var i = 0; i < form.args.length; i++) {
      ret = runTree(form.args[i]);
    }
    return ret;
  }

  let stringify(s: AnyValue): String {
    match (s) {
      is String -> return s.as<String>();
      is Boolean -> if (s.as<Boolean>()) {
        return "1";
      } else {
        return "0";
      }
      is Int -> return s.as<Int>().toString();
      is Float64 -> return s.as<Float64>().toString();
      is List -> return "(${s.as<List<AnyValue>>().join(", ", fn(s: AnyValue) {stringify(s)})})";
      else -> return "?";
    }
  }

  public newLambda(argNames: List<String>, body: Tree, scope: Scope): Extern {
    var self = this;
    return new Extern(fn(args: List<AnyValue>): AnyValue {
      var lastDefs = self.defs;
      var argDefs = new ListBuilder<Def>();
      for (var i = 0; i < args.length; i++) {
        argDefs.add(new Def(argNames[i], args[i]));
      }
      self.setDefs(new LocalScope(scope, argDefs.toList()));
      var ret = self.runTree(body);
      self.setDefs(lastDefs);
      return ret;
    });
  }

  public runLambda(form: Form): AnyValue {
    var args = form.args[0].as<Form>().args.map(fn(s: Tree): String {
      return s.as<Ident>().repr;
    });
    return newLambda(args, form.args[1], defs);
  }

  public runFuncDef(form: Form): AnyValue {
    var name = form.args[0].as<Form>().args[0].as<Ident>().repr;
    var argNames = form.args[1].as<Form>().args.map(fn(x: Tree): String {
      return x.as<Form>().args[0].as<Ident>().repr;
    });
    var def = newLambda(argNames, form.args[2], defs);
    globals.add(new Def(name, def));
    return def;
  }

  public runExternDef(form: Form): AnyValue {}

  public runCall(form: Form): AnyValue {
    var self = this;
    var func = runTree(form.args[0]);
    if (isBad(func)) {
      return func;
    }
    var args = new ListBuilder<AnyValue>();
    for (var i = 1; i < form.args.length; i++) {
      var val = runTree(form.args[i]);
      if (isBad(val)) {
        return val;
      }
      args.add(val);
    }
    // console.log(form.args[0].toString());
    match (func) {
      is Extern -> return callTree(func, args.toList());
      else -> return new Err("not a func: ${form.args[0].toString()} (in: ${defs.toString()})");
    }
  }

  public runForm(form: Form): AnyValue {
    match (form.form) {
      "call" -> return runCall(form);
      "lambda" -> return runLambda(form);
      "extern" -> return runExternDef(form);
      "func" -> return runFuncDef(form);
      "program" -> return runProgram(form);
      else -> return new Err("unknown form: ${form.form}");
    }
  }

  public runIdent(id: Ident): AnyValue {
    return getEnv(id.repr);
  }

  public stringList(id: String): AnyValue {
    var ret: AnyValue = 0;
    var parts = id.split("");
    for (var i = parts.length - 1; i >= 0; i--) {
      var t: List<AnyValue> = [parts[i].codePoints.read(), ret];
      ret = t;
    }
    return ret;
  }

  public runTree(tree: Tree): AnyValue {
    match (tree) {
      is Form -> return runForm(tree.as<Form>());
      is Ident -> return runIdent(tree.as<Ident>());
      is Number -> return tree.as<Number>().repr;
      is Text -> return stringList(tree.as<Text>().repr);
      else -> return new Err("unknown type");
    }
  }

  public getEnv(name: String): AnyValue {
    return defs.lookup(name);
  }

  public callTree(func: AnyValue, args: List<AnyValue>): AnyValue {
    return func.as<Extern>().invoke(args);
  }
}

export let run(tree: Tree): AnyValue {
  var env = new Env();
  env.runTree(tree);
  return env.callTree(env.getEnv("main"), []);
}
