
let {Tree, Form, Ident, Number, Text, Parser} = import("./parser.temper");

class Def {
  public key: String;
  public value: AnyValue;
}

let Cont = fn(AnyValue): Void;
let ExternFunc = fn(List<AnyValue>, Cont): Void;

interface Extern {
  public invoke(args: List<AnyValue>, cont: Cont): Void {}
}

class ExternDefine extends Extern {
  public callback: ExternFunc;
  public invoke(args: List<AnyValue>, cont: Cont): Void {
    return callback(args, cont);
  }
}

class ExternLambda extends Extern {
  public self: Env;
  public argNames: List<String>;
  public body: Tree;
  public scope: Scope;

  public invoke(args: List<AnyValue>, cont: Cont): Void {
    var me = self;
    var lastDefs = self.defs;
    self.setDefs(new LocalScope(scope, argNames, args));
    self.runTree(body, fn(val: AnyValue): Void {
      me.setDefs(lastDefs);
      me.invoke(cont, val);
    });
  }
}

export let isBad(v: AnyValue): Boolean {
  match (v) {
    is Err -> return true;
    else -> return false;
  }
}

class Err {
  public msg: String;
}

interface Scope {
  public lookup(name: String): AnyValue;
  public toString(): String;
}

class GlobalScope extends Scope {
  public vars: ListBuilder<Def>;

  public lookup(name: String): AnyValue {
    for (var i = vars.length-1; i >= 0; i--) {
      if (vars[i].key == name) {
        return vars[i].value;
      }
    }
    return new Err("undefined: ${name}");
  }

  public add(def: Def): Void {
    vars.add(def);
  }

  public toString(): String {
    return "{...}";
  }
}

class LocalScope extends Scope {
  public next: Scope;
  public keys: List<String>;
  public values: List<AnyValue>;

  public lookup(name: String): AnyValue {
    for (var i = 0; i < keys.length; i++) {
      if (keys[i] == name) {
        return values[i];
      }
    }
    return next.lookup(name);
  }

  public toString(): String {
    var my = keys.join(" ", fn(s: String):String{s});
    return "{${my}} ${next.toString()}"
  }
}

let throwAway(v: AnyValue): Void {

}

export class Env {
  public globals: GlobalScope;
  public defs: Scope;
  public parser: Parser;
  public filled: Boolean;
  public func: fn(AnyValue): Void;
  public arg: AnyValue;

  public constructor() {
    globals = new GlobalScope(new ListBuilder<Def>());
    defs = globals;
    parser = new Parser("");
    filled = false;
    define("equal", fn(args: List<AnyValue>, k: Cont): Void {
      if (args[0].as<Int>() == args[1].as<Int>()) {
        k(1);
      } else {
        k(0);
      }
    });
    define("above", fn(args: List<AnyValue>, k: Cont): Void {
      if (args[1].as<Int>() < args[0].as<Int>()) {
        k(1);
      } else {
        k(0);
      }
    });
    define("pair", fn(args: List<AnyValue>, k: Cont): Void {
      k([args[0], args[1]]);
    });
    define("first", fn(args: List<AnyValue>, k: Cont): Void {
      k(args[0].as<List<AnyValue>>()[0]);
    });
    define("second", fn(args: List<AnyValue>, k: Cont): Void {
      k(args[0].as<List<AnyValue>>()[1]);
    });
    define("add", fn(args: List<AnyValue>, k: Cont): Void {
      k(args[1].as<Int>() + args[0].as<Int>());
    });
    define("sub", fn(args: List<AnyValue>, k: Cont): Void {
      k(args[1].as<Int>() - args[0].as<Int>());
    });
    define("mul", fn(args: List<AnyValue>, k: Cont): Void {
      k(args[1].as<Int>() * args[0].as<Int>());
    });
    define("div", fn(args: List<AnyValue>, k: Cont): Void {
      k(args[1].as<Int>() / args[0].as<Int>());
    });
    define("mod", fn(args: List<AnyValue>, k: Cont): Void {
      k(args[1].as<Int>() % args[0].as<Int>());
    });
    var buf = new ListBuilder<Int>();
    define("putchar", fn(args: List<AnyValue>, k: Cont): Void {
      var c = args[0].as<Int>();
      if (c == 10) {
        let {fromAsciiCode} = import("./ascii.temper");
        console.log(buf.join("", fromAsciiCode));
        buf = new ListBuilder<Int>();
      } else {
        buf.add(c);
      }
      k(0);
    });
    define("if", fn(args: List<AnyValue>, k: Cont): Void {
      match (args[0]) {
        0 -> args[2].as<Extern>().invoke([], k);
        else -> args[1].as<Extern>().invoke([], k);
      }
    });
  }

  public invoke(func_: fn(AnyValue): Void, arg_: AnyValue): Boolean {
    func = func_;
    arg = arg_;
    filled = true;
  }

  public setDefs(scope: Scope): Void {
    defs = scope;
  }

  public define(name: String, value: ExternFunc): Void {
    globals.add(new Def(name, new ExternDefine(value)));
  }

  public run(): Void {
    while (filled) {
      filled = false;
      func(arg);
    }
  }

  public source(code: String): Void {
    parser.setState(code);
    runTree(parser.readDefs(), throwAway);
    run();
  }

  public call(name: String, args: List<AnyValue>): AnyValue {
    var self = this;
    var realArgs = args.map(fn(v: AnyValue): AnyValue {
      match (v) {
        is String -> return self.stringList(v.as<String>());
        else -> return v;
      }
    });
    var res: AnyValue = 0;
    callTree(getEnv(name), realArgs, fn(v: AnyValue): Void {
      res = v;
    });
    run();
    return res;
  }

  public runProgram(form: Form, cont: Cont): Void {
    for (var i = 0; i < form.args.length; i++) {
      runTree(form.args[i], throwAway);
    }
  }

  public newLambda(argNames: List<String>, body: Tree, scope: Scope): Extern {
    return new ExternLambda(this, argNames, body, scope);
  }

  public runLambda(form: Form, cont: Cont): Void {
    var args = form.args[0].as<Form>().args.map(fn(s: Tree): String {
      return s.as<Ident>().repr;
    });
    invoke(cont, newLambda(args, form.args[1], defs));
  }

  public runFuncDef(form: Form, cont: Cont): Void {
    var name = form.args[0].as<Form>().args[0].as<Ident>().repr;
    var argNames = form.args[1].as<Form>().args.map(fn(x: Tree): String {
      return x.as<Form>().args[0].as<Ident>().repr;
    });
    globals.add(new Def(name, newLambda(argNames, form.args[2], defs)));
  }

  public runDo(form: Form, cont: Cont): Void {
    if (form.args.length == 0) {
      cont(new Err("unreachable"));
    } else {
      runTree(form.args[0], cont);
    }
  }

  public runExternDef(form: Form, cont: Cont): Void {}

  public runCall(form: Form, cont: Cont): Void {
    var self = this;
    runTree(form.args[0], fn(func: AnyValue): Void {
      if (isBad(func)) {
        self.invoke(cont, func);
      } else {
        var args = new ListBuilder<AnyValue>();
        let more(): Void {
          var i = args.length + 1;
          if (i < form.args.length) {
            self.runTree(form.args[i], fn(v: AnyValue) {
              if (isBad(v)) {
                cont(v);
              } else {
                args.add(v);
                more();
              }
            });
          } else {
            self.callTree(func, args.toList(), cont);
          }
        }
        more();
      }
    })
  }

  public runForm(form: Form, cont: Cont): Void {
    match (form.form) {
      "call" -> runCall(form, cont);
      "lambda" -> runLambda(form, cont);
      "do" -> runDo(form, cont);
      "extern" -> runExternDef(form, throwAway);
      "func" -> runFuncDef(form, throwAway);
      "program" -> runProgram(form, throwAway);
      else -> invoke(cont, new Err("unknown form: ${form.form}"));
    }
  }

  public runIdent(id: Ident, cont: Cont): Void {
    invoke(cont, getEnv(id.repr));
  }

  public stringList(id: String): AnyValue {
    var ret: AnyValue = 0;
    var parts = id.split("");
    for (var i = parts.length - 1; i >= 0; i--) {
      var t: List<AnyValue> = [parts[i].codePoints.read(), ret];
      ret = t;
    }
    return ret;
  }

  public runTree(tree: Tree, cont: Cont): Void {
    match (tree) {
      is Form -> runForm(tree.as<Form>(), cont);
      is Ident -> runIdent(tree.as<Ident>(), cont);
      is Number -> invoke(cont, tree.as<Number>().repr);
      is Text -> invoke(cont, stringList(tree.as<Text>().repr));
      else -> invoke(cont, new Err("unknown type"));
    }
  }

  public getEnv(name: String): AnyValue {
    return defs.lookup(name);
  }

  public callTree(func: AnyValue, args: List<AnyValue>, cont: Cont): Void {
    func.as<Extern>().invoke(args, cont);
  }
}
